From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Kleis Auke Wolthuizen <github@kleisauke.nl>
Date: Thu, 22 Sep 2022 20:20:37 +0200
Subject: [PATCH 1/1] Fix `EXPORT_ES6` on Node.js

Upstream-Status: Submitted [https://github.com/emscripten-core/emscripten/pull/17915]

diff --git a/emcc.py b/emcc.py
index 1111111..2222222 100644
--- a/emcc.py
+++ b/emcc.py
@@ -3010,6 +3010,7 @@ def phase_final_emitting(options, state, target, wasm_target, memfile):
     src = read_file(final_js)
     final_js += '.esmeta.js'
     write_file(final_js, src.replace('EMSCRIPTEN$IMPORT$META', 'import.meta'))
+    shared.get_temp_files().note(final_js)
     save_intermediate('es6-import-meta')
 
   # Apply pre and postjs files
@@ -3576,6 +3577,35 @@ def phase_binaryen(target, options, wasm_target):
     write_file(final_js, js)
 
 
+def node_es6_imports():
+  if not settings.EXPORT_ES6 or not shared.target_environment_may_be('node'):
+    return ''
+
+  if settings.USE_ES6_IMPORT_META:
+    import_script_url = 'import.meta.url'
+  else:
+    import_script_url = "pathToFileURL('.')"
+
+  # Avoid Node specific imports in browser.
+  # TODO: Swap all `require()`'s with `import()`'s?
+  if shared.target_environment_may_be('web'):
+    return '''
+if (typeof process == 'object' &&
+    typeof process.versions == 'object' &&
+    typeof process.versions.node == 'string') {
+  const { createRequire } = await import('module');
+  var { pathToFileURL, fileURLToPath } = await import('url');
+  var require = createRequire(%s);
+}
+''' % import_script_url
+  else:
+    return '''
+import { createRequire } from 'module';
+import { pathToFileURL, fileURLToPath } from 'url';
+const require = createRequire(%s);
+''' % import_script_url
+
+
 def modularize():
   global final_js
   logger.debug(f'Modularizing, assigning to var {settings.EXPORT_NAME}')
@@ -3606,24 +3636,25 @@ function(%(EXPORT_NAME)s) {
     # document.currentScript, so a simple export declaration is enough.
     src = 'var %s=%s' % (settings.EXPORT_NAME, src)
   else:
-    script_url_node = ""
+    script_url_node = ''
     # When MODULARIZE this JS may be executed later,
     # after document.currentScript is gone, so we save it.
     # In EXPORT_ES6 + USE_PTHREADS the 'thread' is actually an ES6 module webworker running in strict mode,
     # so doesn't have access to 'document'. In this case use 'import.meta' instead.
     if settings.EXPORT_ES6 and settings.USE_ES6_IMPORT_META:
-      script_url = "import.meta.url"
+      script_url = 'import.meta.url'
     else:
       script_url = "typeof document !== 'undefined' && document.currentScript ? document.currentScript.src : undefined"
       if shared.target_environment_may_be('node'):
         script_url_node = "if (typeof __filename !== 'undefined') _scriptDir = _scriptDir || __filename;"
-    src = '''
+    src = '''%(node_imports)s
 var %(EXPORT_NAME)s = (() => {
   var _scriptDir = %(script_url)s;
   %(script_url_node)s
   return (%(src)s);
 })();
 ''' % {
+      'node_imports': node_es6_imports(),
       'EXPORT_NAME': settings.EXPORT_NAME,
       'script_url': script_url,
       'script_url_node': script_url_node,
diff --git a/src/closure-externs/node-externs.js b/src/closure-externs/node-externs.js
index 1111111..2222222 100644
--- a/src/closure-externs/node-externs.js
+++ b/src/closure-externs/node-externs.js
@@ -111,3 +111,13 @@ Buffer.prototype.slice = function(start, end) {};
  * @nosideeffects
  */
 Buffer.prototype.toString = function(encoding, start, end) {};
+
+/**
+ * @param {string} path
+ */
+var pathToFileURL = function(path) {};
+
+/**
+ * @param {URL|string} url
+ */
+var fileURLToPath = function(url) {};
diff --git a/src/node_shell_read.js b/src/node_shell_read.js
index 1111111..2222222 100644
--- a/src/node_shell_read.js
+++ b/src/node_shell_read.js
@@ -4,21 +4,6 @@
  * SPDX-License-Identifier: MIT
  */
 
-// These modules will usually be used on Node.js. Load them eagerly to avoid
-// the complexity of lazy-loading. However, for now we must guard on require()
-// actually existing: if the JS is put in a .mjs file (ES6 module) and run on
-// node, then we'll detect node as the environment and get here, but require()
-// does not exist (since ES6 modules should use |import|). If the code actually
-// uses the node filesystem then it will crash, of course, but in the case of
-// code that never uses it we don't want to crash here, so the guarding if lets
-// such code work properly. See discussion in
-// https://github.com/emscripten-core/emscripten/pull/17851
-var fs, nodePath;
-if (typeof require === 'function') {
-  fs = require('fs');
-  nodePath = require('path');
-}
-
 read_ = (filename, binary) => {
 #if SUPPORT_BASE64_EMBEDDING
   var ret = tryParseAsDataURI(filename);
diff --git a/src/preamble.js b/src/preamble.js
index 1111111..2222222 100644
--- a/src/preamble.js
+++ b/src/preamble.js
@@ -649,7 +649,13 @@ if (Module['locateFile']) {
 #if EXPORT_ES6 && USE_ES6_IMPORT_META && !SINGLE_FILE // in single-file mode, repeating WASM_BINARY_FILE would emit the contents again
 } else {
   // Use bundler-friendly `new URL(..., import.meta.url)` pattern; works in browsers too.
-  wasmBinaryFile = new URL('{{{ WASM_BINARY_FILE }}}', import.meta.url).toString();
+  wasmBinaryFile = new URL('{{{ WASM_BINARY_FILE }}}', import.meta.url);
+#if ENVIRONMENT_MAY_BE_NODE
+  if (ENVIRONMENT_IS_NODE) {
+    wasmBinaryFile = fileURLToPath(wasmBinaryFile);
+  } else
+#endif
+    wasmBinaryFile = wasmBinaryFile.href;
 }
 #endif
 
diff --git a/src/shell.js b/src/shell.js
index 1111111..2222222 100644
--- a/src/shell.js
+++ b/src/shell.js
@@ -193,11 +193,20 @@ if (ENVIRONMENT_IS_NODE) {
   if (typeof process == 'undefined' || !process.release || process.release.name !== 'node') throw new Error('not compiled for this environment (did you build to HTML and try to run it not on the web, or set ENVIRONMENT to something - like node - and run it someplace else - like on the web?)');
 #endif
 #endif
+  var fs = require('fs');
+  var nodePath = require('path');
+
   if (ENVIRONMENT_IS_WORKER) {
-    scriptDirectory = require('path').dirname(scriptDirectory) + '/';
+    scriptDirectory = nodePath.dirname(scriptDirectory);
   } else {
-    scriptDirectory = __dirname + '/';
+#if EXPORT_ES6
+    scriptDirectory = nodePath.dirname(fileURLToPath(import.meta.url));
+#else
+    scriptDirectory = __dirname;
+#endif
   }
+  // Ensure trailing slash
+  scriptDirectory += '/';
 
 #include "node_shell_read.js"
 
